package templater

import (
	"errors"
	"fmt"
	"text/template"

	"github.com/treeverse/lakefs/pkg/auth"
	"github.com/treeverse/lakefs/pkg/permissions"
)

var (
	ErrNotAuthorized = errors.New("unauthorized")
	// ErrTemplateFailed is an error generated by the "fail" template function.
	ErrTemplateFailed = errors.New("")
)

type Credentials struct {
	Key, Secret string
}

var templateFuncs = template.FuncMap{
	"new_credentials": newCredentials,
	"fail":            fail,
}

// newCredentials creates new credentials for the user and returns them.
func newCredentials(params *ControlledParams) (*Credentials, error) {
	resp, err := params.Auth.Authorize(params.Ctx, &auth.AuthorizationRequest{
		Username: params.User.Username,
		RequiredPermissions: permissions.Node{
			Permission: permissions.Permission{
				Action:   permissions.CreateCredentialsAction,
				Resource: permissions.UserArn(params.User.Username),
			},
		},
	})
	if err == nil && resp.Error != nil {
		err = resp.Error
	}
	if err != nil {
		return nil, fmt.Errorf("create credentials for %+v: %w", params.User, err)
	}
	if !resp.Allowed {
		return nil, fmt.Errorf("create credentials for %+v: %w", params.User, ErrNotAuthorized)
	}

	// TODO(ariels): monitor!

	credentials, err := params.Auth.CreateCredentials(params.Ctx, params.User.Username)
	if err != nil {
		return nil, fmt.Errorf("create credentials for %+v: %w", params.User, err)
	}

	return &Credentials{Key: credentials.AccessKeyID, Secret: credentials.SecretAccessKey}, nil
}

// fail fails template expansion with the message passed in.
func fail(_ *ControlledParams, msg string) (string, error) {
	return msg, fmt.Errorf("%s%w", msg, ErrTemplateFailed)
}

// TODO(ariels): config, object, contenttype
